{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport * as React from 'react';\nimport TextInput from \"react-native-web/dist/exports/TextInput\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\nvar KeyboardManager = function (_React$Component) {\n  _inherits(KeyboardManager, _React$Component);\n  var _super = _createSuper(KeyboardManager);\n  function KeyboardManager() {\n    var _this;\n    _classCallCheck(this, KeyboardManager);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"previouslyFocusedTextInput\", null);\n    _defineProperty(_assertThisInitialized(_this), \"startTimestamp\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"keyboardTimeout\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"clearKeyboardTimeout\", function () {\n      if (_this.keyboardTimeout !== undefined) {\n        clearTimeout(_this.keyboardTimeout);\n        _this.keyboardTimeout = undefined;\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handlePageChangeStart\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n      _this.clearKeyboardTimeout();\n      var input = TextInput.State.currentlyFocusedInput ? TextInput.State.currentlyFocusedInput() : TextInput.State.currentlyFocusedField();\n      TextInput.State.blurTextInput(input);\n      _this.previouslyFocusedTextInput = input;\n      _this.startTimestamp = Date.now();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handlePageChangeConfirm\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n      _this.clearKeyboardTimeout();\n      var input = _this.previouslyFocusedTextInput;\n      if (Platform.OS === 'android') {\n        Keyboard.dismiss();\n      } else if (input) {\n        TextInput.State.blurTextInput(input);\n      }\n      _this.previouslyFocusedTextInput = null;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handlePageChangeCancel\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n      _this.clearKeyboardTimeout();\n      var input = _this.previouslyFocusedTextInput;\n      if (input) {\n        if (Date.now() - _this.startTimestamp < 100) {\n          _this.keyboardTimeout = setTimeout(function () {\n            TextInput.State.focusTextInput(input);\n            _this.previouslyFocusedTextInput = null;\n          }, 100);\n        } else {\n          TextInput.State.focusTextInput(input);\n          _this.previouslyFocusedTextInput = null;\n        }\n      }\n    });\n    return _this;\n  }\n  _createClass(KeyboardManager, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearKeyboardTimeout();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children({\n        onPageChangeStart: this.handlePageChangeStart,\n        onPageChangeConfirm: this.handlePageChangeConfirm,\n        onPageChangeCancel: this.handlePageChangeCancel\n      });\n    }\n  }]);\n  return KeyboardManager;\n}(React.Component);\nexport { KeyboardManager as default };","map":{"version":3,"sources":["KeyboardManager.tsx"],"names":["React","KeyboardManager","Component","clearKeyboardTimeout","keyboardTimeout","undefined","clearTimeout","props","enabled","input","TextInput","State","currentlyFocusedInput","currentlyFocusedField","blurTextInput","previouslyFocusedTextInput","startTimestamp","Date","now","Platform","OS","Keyboard","dismiss","setTimeout","focusTextInput","children","onPageChangeStart","handlePageChangeStart","onPageChangeConfirm","handlePageChangeConfirm","onPageChangeCancel","handlePageChangeCancel"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAAA;AAAA;AAAA;AAAA,IAYqBC,eAAN;EAAA;EAAA;EAAqD,2BAAA;IAAA;IAAA;IAAA,kCAAA,IAAA;MAAA,IAAA;IAAA;IAAA,gDAAA,IAAA;IAAA,eAAA,gCAAA,4BAAA,EAOd,IAPc,CAAA;IAAA,eAAA,gCAAA,gBAAA,EAQjC,CARiC,CAAA;IAAA,eAAA,gCAAA,iBAAA,EAAA,KAAA,CAAA,CAAA;IAAA,eAAA,gCAAA,sBAAA,EAWnC,YAAM;MACnC,IAAI,MAAKG,eAAL,KAAyBC,SAA7B,EAAwC;QACtCC,YAAY,CAAC,MAAKF,eAAN,CAAZE;QACA,MAAKF,eAAL,GAAuBC,SAAvB;MACD;IACF,CAhBiE,CAAA;IAAA,eAAA,gCAAA,uBAAA,EAkBlC,YAAM;MACpC,IAAI,CAAC,MAAKE,KAAL,CAAWC,OAAhB,EAAyB;QACvB;MACD;MAED,MAAKL,oBAAL,EALoC;MAQpC,IAAMM,KAAK,GAAGC,SAAS,CAACC,KAAVD,CAAgBE,qBAAhBF,GAEVA,SAAS,CAACC,KAAVD,CAAgBE,qBAAhBF,EAFUA,GAGVA,SAAS,CAACC,KAAVD,CAAgBG,qBAAhBH,EAXgC;MAcpCA,SAAS,CAACC,KAAVD,CAAgBI,aAAhBJ,CAA8BD,KAA9BC,CAdoC;MAiBpC,MAAKK,0BAAL,GAAkCN,KAjBE;MAoBpC,MAAKO,cAAL,GAAsBC,IAAI,CAACC,GAALD,EAAtB;IACD,CAvCiE,CAAA;IAAA,eAAA,gCAAA,yBAAA,EAyChC,YAAM;MACtC,IAAI,CAAC,MAAKV,KAAL,CAAWC,OAAhB,EAAyB;QACvB;MACD;MAED,MAAKL,oBAAL,EAAA;MAEA,IAAMM,KAAK,GAAG,MAAKM,0BAAnB;MAEA,IAAII,QAAQ,CAACC,EAATD,KAAgB,SAApB,EAA+B;QAC7BE,QAAQ,CAACC,OAATD,EAAAA;MACD,CAFD,MAEO,IAAIZ,KAAJ,EAAW;QAChBC,SAAS,CAACC,KAAVD,CAAgBI,aAAhBJ,CAA8BD,KAA9BC,CAAAA;MAZoC;MAgBtC,MAAKK,0BAAL,GAAkC,IAAlC;IACD,CA1DiE,CAAA;IAAA,eAAA,gCAAA,wBAAA,EA4DjC,YAAM;MACrC,IAAI,CAAC,MAAKR,KAAL,CAAWC,OAAhB,EAAyB;QACvB;MACD;MAED,MAAKL,oBAAL,EALqC;MAQrC,IAAMM,KAAK,GAAG,MAAKM,0BAAnB;MAEA,IAAIN,KAAJ,EAAW;QAQT,IAAIQ,IAAI,CAACC,GAALD,EAAAA,GAAa,MAAKD,cAAlBC,GAAmC,GAAvC,EAA4C;UAC1C,MAAKb,eAAL,GAAuBmB,UAAU,CAAC,YAAM;YACtCb,SAAS,CAACC,KAAVD,CAAgBc,cAAhBd,CAA+BD,KAA/BC,CAAAA;YACA,MAAKK,0BAAL,GAAkC,IAAlC;UACD,CAHgC,EAG9B,GAH8B,CAAjC;QAID,CALD,MAKO;UACLL,SAAS,CAACC,KAAVD,CAAgBc,cAAhBd,CAA+BD,KAA/BC,CAAAA;UACA,MAAKK,0BAAL,GAAkC,IAAlC;QACD;MACF;IACF,CAxFiE,CAAA;IAAA;EAAA;EAAA;IAAA;IAAA,uCAC3C;MACrB,IAAA,CAAKZ,oBAAL,EAAA;IACD;EAHiE;IAAA;IAAA,yBA0FzD;MACP,OAAO,IAAA,CAAKI,KAAL,CAAWkB,QAAX,CAAoB;QACzBC,iBAAiB,EAAE,IAAA,CAAKC,qBADC;QAEzBC,mBAAmB,EAAE,IAAA,CAAKC,uBAFD;QAGzBC,kBAAkB,EAAE,IAAA,CAAKC;MAHA,CAApB,CAAP;IAKD;EAAA;EAAA;AAAA,EAhG0C/B,KAAK,CAACE,SAApC;AAAA,SAAMD,eAAN","sourcesContent":["import * as React from 'react';\nimport { TextInput, Platform, Keyboard } from 'react-native';\n\ntype Props = {\n  enabled: boolean;\n  children: (props: {\n    onPageChangeStart: () => void;\n    onPageChangeConfirm: () => void;\n    onPageChangeCancel: () => void;\n  }) => React.ReactNode;\n};\n\nexport default class KeyboardManager extends React.Component<Props> {\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  }\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: number | null = null;\n  private startTimestamp: number = 0;\n  private keyboardTimeout: any;\n\n  private clearKeyboardTimeout = () => {\n    if (this.keyboardTimeout !== undefined) {\n      clearTimeout(this.keyboardTimeout);\n      this.keyboardTimeout = undefined;\n    }\n  };\n\n  private handlePageChangeStart = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // @ts-expect-error: currentlyFocusedInput is pretty new, so not in the type definitions\n    const input = TextInput.State.currentlyFocusedInput\n      ? // @ts-expect-error\n        TextInput.State.currentlyFocusedInput()\n      : TextInput.State.currentlyFocusedField();\n\n    // When a page change begins, blur the currently focused input\n    TextInput.State.blurTextInput(input);\n\n    // Store the id of this input so we can refocus it if change was cancelled\n    this.previouslyFocusedTextInput = input;\n\n    // Store timestamp for touch start\n    this.startTimestamp = Date.now();\n  };\n\n  private handlePageChangeConfirm = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    const input = this.previouslyFocusedTextInput;\n\n    if (Platform.OS === 'android') {\n      Keyboard.dismiss();\n    } else if (input) {\n      TextInput.State.blurTextInput(input);\n    }\n\n    // Cleanup the ID on successful page change\n    this.previouslyFocusedTextInput = null;\n  };\n\n  private handlePageChangeCancel = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // The page didn't change, we should restore the focus of text input\n    const input = this.previouslyFocusedTextInput;\n\n    if (input) {\n      // If the interaction was super short we should make sure keyboard won't hide again.\n\n      // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n      // During first ~100ms keyboard will be dismissed no matter what,\n      // so we have to make sure it won't interrupt input refocus logic.\n      // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n      // Subtracting timestamps makes us sure the delay is executed only when needed.\n      if (Date.now() - this.startTimestamp < 100) {\n        this.keyboardTimeout = setTimeout(() => {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = null;\n        }, 100);\n      } else {\n        TextInput.State.focusTextInput(input);\n        this.previouslyFocusedTextInput = null;\n      }\n    }\n  };\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}